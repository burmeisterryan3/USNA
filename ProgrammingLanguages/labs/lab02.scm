(define (conv-rate cur)
  (cond ((eqv? cur 'euro)
         0.76)
        ((eqv? cur 'yen)
         98.18)
        ((eqv? cur 'won)
         1109.85)
        ((eqv? cur 'usd)
         1)
        )
  )

(define (to-usdollar amt cur)
  (if (number? amt) 
      (if (> amt 0) 
          (/ amt (conv-rate cur))
          '())
      '()
      )
  )

(define (from-usdollar amt cur)
  (if (number? amt) 
      (if (>= amt 0) 
          (* amt (conv-rate cur))
          '())
      '()
      )
  )

(define (convert amt fromCur toCur)
  (if (number? amt)
      (if (>= amt 0)
          (from-usdollar (to-usdollar amt fromCur) toCur)
          '()
          )
      '()
      )
  )

(define (squares i j)
  (if (> i j)
      '()
      (cons (expt i 2)
            (squares (+ i 1) j)
            )
      )
  )

(define (longer? L1 L2)
  (if (null? L1)
      #f
      (if (null? L2)
          #t
          (longer? (cdr L1) (cdr L2))
          )
      )
  )

(define (sum-cash L)
  (if (null? L)
      0
      (+ (to-usdollar (car (car L)) (cadr (car L)))
         (sum-cash (cdr L)))
      )
  )

(define (sum L)
  (if (null? L)
      0
      (+ (car L)
         (sum (cdr L)))
      )
  )

(define (count-elements L)
  (if (null? L)
      0
      (+ 1 (count-elements (cdr L)))
      )
  )

(define (average L)
  (/ (sum L) (count-elements L))
  )

(define (numer L avg)
  (if (null? L)
      0
      (+ (expt (- (car L) avg) 2)
         (numer (cdr L) avg))
      )
  )

(define (std-dev L)
  (sqrt (/ (numer L (average L))
           (- (count-elements L) 1)))
  )

(define (test-sin x)
  (let ((a (+ 1 (expt (sin x) 2))))
    (+ (/ 1 a)
       (sqrt a)
       (* -1 (expt a 2)))
    )
  )

(define (dist a b c d)
  (let ((L1 (+ b (* a 12)))
        (L2 (+ d (* c 12))))
    (abs (- L1 L2))
    )
  )

(define (fd-at g x)
  (- (g (+ x 1)) (g x))
  )

(define (filter pred? L)
  (cond ((null? L) '())
        ((pred? (car L))
         (cons (car L) (filter pred? (cdr L))))
        (else (filter pred? (cdr L)))))

; Returns a list containing integers a, a+1, ..., b.
(define (range a b)
  (if (> a b)
      '()
      (cons a (range (+ a 1) b))))

(define (sqrt-prod n)
  (apply * (map sqrt (range 1 n)))
  )

(define (sqr x) (* x x))

(define (div-three L)
  (if (null? L)
      '()
      (if (= 0 (modulo (car L) 3))
          (cons (car L) (div-three (cdr L)))
          (div-three (cdr L))
          )
      )
  )

(define (special-nums n)
  (define squared (map sqr (range 1 (floor (sqrt n)))))
  (div-three squared)
  )